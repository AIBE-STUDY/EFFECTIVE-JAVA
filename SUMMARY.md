# Table of contents

* [🍄 All About Effective Java](README.md)

## 🐢 All About Study

* [🧩 스터디 진행 방식](all-about-study/howtostudy.md)
* [🔎 아이템 체크리스트](all-about-study/checklist.md)

## 💾 Effective Java

* [2️⃣ 객체 생성과 파괴](effective-java/section2/README.md)
  * [1. 생성자 대신 정적 팩터리 메서드를 고려하라](effective-java/section2/1.Consider_static_factory_methods_instead_of_constructors.md)
  * [2. 생성자에 매개변수가 많다면 빌더를 고려하라](effective-java/section2/2.Consider_a_builder_when_faced_with_many_constructor_parameters.md)
  * [3. private 생성자나 열거 타입으로 싱글턴임을 보증하라](effective-java/section2/3.Enforce_the_singleton_property_with_a_private_constructor_or_an_enum_type.md)
  * [4. 인스턴스화를 막으려거든 private 생성자를 사용하라](effective-java/section2/4.Enforce_noninstantiability_with_a_private_constructor.md)
  * [5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라](effective-java/section2/5.Prefer_dependency_injection_to_hardwiring_resources.md)
  * [6. 불필요한 객체 생성을 피하라](effective-java/section2/6.Avoid_creating_unnecessary_objects.md)
  * [7. 다 쓴 객체 참조를 해제하라](effective-java/section2/7.Eliminate_obsolete_object_references.md)
  * [8. finalizer와 cleaner 사용을 피하라](effective-java/section2/8.Avoid_finalizers_and_cleaners.md)
  * [9. try-finally보다는 try-with-resources를 사용하라](effective-java/section2/9.Prefer-try-with-resources-to-try-finally.md)
* [3️⃣ 모든 객체의 공통 메서드](effective-java/section3/README.md)
  * [10. equals는 일반 규약을 지켜 재정의하라](effective-java/section3/10.Obey_the_general_contract_when_overriding_equals.md)
  * [11. equals를 재정의하려거든 hashCode도 재정의하라](effective-java/section3/11.Always_override_hashCode_when_you_override_equals.md)
  * [12. toString을 항상 재정의하라](effective-java/section3/12.Always_override_toString.md)
  * [13. clone 재정의는 주의해서 진행하라](effective-java/section3/13.Override_clone_judiciously.md)
  * [14. Comparable을 구현할지 고려하라](effective-java/section3/14.Consider_implementing_Comparable.md)
* [4️⃣ 클래스와 인터페이스](effective-java/section4/README.md)
  * [15. 클래스와 멤버의 접근 권한을 최소화하라](effective-java/section4/15.Minimize_the_accessibility_of_classes_and_members.md)
  * [16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라](effective-java/section4/16.In_public_classes,_use_accessor_methods,_not_public_fields.md)
  * [17. 변경 가능성을 최소화하라](effective-java/section4/17.Minimize_mutability.md)
  * [18. 상속보다는 컴포지션을 사용하라](effective-java/section4/18.Favor_composition_over_inheritance.md)
  * [19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라](effective-java/section4/19.Design_and_document_for_inheritance_or_else_prohibit_it.md)
  * [20. 추상 클래스보다는 인터페이스를 우선하라](effective-java/section4/20.Prefer_interfaces_to_abstract_classes.md)
  * [21. 인터페이스는 구현하는 쪽을 생각해 설계하라](effective-java/section4/21.Design_interfaces_for_posterity.md)
  * [22. 인터페이스는 타입을 정의하는 용도로만 사용하라](effective-java/section4/22.Use_interfaces_only_to_define_types.md)
  * [23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라](effective-java/section4/23.Prefer_class_hierarchies_to_tagged_classes.md)
  * [24. 멤버 클래스는 되도록 static으로 만들라](effective-java/section4/24.Favor_static_member_classes_over_nonstatic.md)
  * [25. 톱레벨 클래스는 한 파일에 하나만 담으라](effective-java/section4/25.Limit_source_files_to_a_single_top_level_class.md)
* [5️⃣ 제네릭](effective-java/undefined/README.md)
  * [26. 로 타입은 사용하지 말라](effective-java/section5/26.Dont_use_raw_types.md)
  * [27. 비검사 경고를 제거하라](effective-java/section5/27.Eliminate_unchecked_warnings.md)
  * [28. 배열보다는 리스트를 사용하라](effective-java/section5/28.Prefer_lists_to_arrays.md)
  * [29. 이왕이면 제네릭 타입으로 만들라](effective-java/section5/29.Favor_generic_types.md)
  * [30. 이왕이면 제네릭 메서드로 만들라](effective-java/section5/30.Favor_generic_methods.md)
  * [31. 한정적 와일드카드를 사용해 API 유연성을 높이라](effective-java/section5/31.Use_bounded_wildcards_to_increase_API_flexibility.md)
  * [32. 제네릭과 가변인수를 함께 쓸 때는 신중하라](effective-java/section5/32.Combine_generics_and_varargs_judiciously.md)
  * [33. 타입 안전 이종 컨테이너를 고려하라](effective-java/section5/33.Consider_typesafe_heterogeneous_containers.md)
* [6️⃣ 열거 타입과 애너테이션](effective-java/undefined-1/README.md)
  * [34. int 상수 대신 열거 타입을 사용하라](effective-java/section6/34.Use_enums_instead_of_int_constants.md)
  * [35. ordinal 메서드 대신 인스턴스 필드를 사용하라](effective-java/section6/35.Use_instance_fields_instead_of_ordinals.md)
  * [36. 비트 필드 대신 EnumSet을 사용하라](effective-java/section6/36.Use_EnumSet_instead_of_bit_fields.md)
  * [37. ordinal 인덱싱 대신 EnumMap을 사용하라](effective-java/section6/37.Use_EnumMap_instead_of_ordinal_indexing.md)
  * [38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라](effective-java/section6/38.Emulate_extensible_enums_with_interfaces.md)
  * [39. 명명 패턴보다 애너테이션을 사용하라](effective-java/section6/39.Prefer_annotations_to_naming_patterns.md)
  * [40. @Override 애너테이션을 일관되게 사용하라](effective-java/section6/40.Consistently_use_the_Override_annotation.md)
  * [41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라](effective-java/section6/41.Use_marker_interfaces_to_define_types.md)
* [7️⃣ 람다와 스트림](effective-java/undefined-2/README.md)
  * [42. 익명 클래스보다는 람다를 사용하라](effective-java/section7/42.Prefer_lambdas_to_anonymous_classes.md)
  * [43. 람다보다는 메서드 참조를 사용하라](effective-java/section7/43.Prefer_method_references_to_lambdas.md)
  * [44. 표준 함수형 인터페이스를 사용하라](effective-java/section7/44.Favor_the_use_of_standard_functional_interfaces.md)
  * [45. 스트림은 주의해서 사용하라](effective-java/section7/45.Use_streams_judiciously.md)
  * [46. 스트림에서는 부작용 없는 함수를 사용하라](effective-java/section7/46.Prefer_side_effect_free_functions_in_streams.md)
  * [47. 반환 타입으로는 스트림보다 컬렉션이 낫다](effective-java/section7/47.Prefer_Collection_to_Stream_as_a_return_type.md)
  * [48. 스트림 병렬화는 주의해서 적용하라](effective-java/section7/48.Use_caution_when_making_streams_parallel.md)
* [8️⃣ 메서드](effective-java/undefined-3/README.md)
  * [49. 매개변수가 유효한지 검사하라](effective-java/section8/49.Check_parameters_for_validity.md)
  * [50. 적시에 방어적 복사본을 만들라](effective-java/section8/50.Make_defensive_copies_when_needed.md)
  * [51. 메서드 시그니처를 신중히 설계하라](effective-java/section8/51.Design_method_signatures_carefully.md)
  * [52. 다중정의는 신중히 사용하라](effective-java/section8/52.Use_overloading_judiciously.md)
  * [53. 가변인수는 신중히 사용하라](effective-java/section8/53.Use_varargs_judiciously.md)
  * [54. null이 아닌, 빈 컬렉션이나 배열을 반환하라](effective-java/section8/54.Return_empty_collections_or_arrays,_not_nulls.md)
  * [55. 옵셔널 반환은 신중히 하라](effective-java/section8/55.Return_optionals_judiciously.md)
  * [56. 공개된 API 요소에는 항상 문서화 주석을 작성하라](effective-java/section8/56.Write_doc_comments_for_all_exposed_API_elements.md)
* [9️⃣ 일반적인 프로그래밍 원칙](effective-java/undefined-4/README.md)
  * [57. 지역변수의 범위를 최소화하라](effective-java/section9/57.Minimize_the_scope_of_local_variables.md)
  * [58. 전통적인 for 문보다는 for-each 문을 사용하라](effective-java/section9/58.Prefer_for_each_loops_to_traditional_for_loops.md)
  * [59. 라이브러리를 익히고 사용하라](effective-java/section9/59.Know_and_use_the_libraries.md)
  * [60. 정확한 답이 필요하다면 float와 double은 피하라](effective-java/section9/60.Avoid_float_and_double_if_exact_answers_are_required.md)
  * [61. 박싱된 기본 타입보다는 기본 타입을 사용하라](effective-java/section9/61.Prefer_primitive_types_to_boxed_primitives.md)
  * [62. 다른 타입이 적절하다면 문자열 사용을 피하라](effective-java/section9/62.Avoid_strings_where_other_types_are_more_appropriate.md)
  * [63. 문자열 연결은 느리니 주의하라](effective-java/section9/63.Beware_the_performance_of_string_concatenation.md)
  * [64. 객체는 인터페이스를 사용해 참조하라](effective-java/section9/64.Refer_to_objects_by_their_interfaces.md)
  * [65. 리플렉션보다는 인터페이스를 사용하라](effective-java/section9/65.Prefer_interfaces_to_reflection.md)
  * [66. 네이티브 메서드는 신중히 사용하라](effective-java/section9/66.Use_native_methods_judiciously.md)
  * [67. 최적화는 신중히 하라](effective-java/section9/67.Optimize_judiciously.md)
  * [68. 일반적으로 통용되는 명명 규칙을 따르라](effective-java/section9/68.Adhere_to_generally_accepted_naming_conventions.md)
* [🔟 예외](effective-java/undefined-5/README.md)
  * [69. 예외는 진짜 예외 상황에만 사용하라](effective-java/section10/69.Use_exceptions_only_for_exceptional_conditions.md)
  * [70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라](effective-java/section10/70.Use_checked_exceptions_for_recoverable_conditions_and_runtime_exceptions_for_programming_errors.md)
  * [71. 필요 없는 검사 예외 사용은 피하라](effective-java/section10/71.Avoid_unnecessary_use_of_checked_exceptions.md)
  * [72. 표준 예외를 사용하라](effective-java/section10/72.Favor_the_use_of_standard_exceptions.md)
  * [73. 추상화 수준에 맞는 예외를 던지라](effective-java/section10/73.Throw_exceptions_appropriate_to_the_abstraction.md)
  * [74. 메서드가 던지는 모든 예외를 문서화하라](effective-java/section10/74.Document_all_exceptions_thrown_by_each_method.md)
  * [75. 예외의 상세 메시지에 실패 관련 정보를 담으라](effective-java/section10/75.Include_failure_capture_information_in_detail_messages.md)
  * [76. 가능한 한 실패 원자적으로 만들라](effective-java/section10/76.Strive_for_failure_atomicity.md)
  * [77. 예외를 무시하지 말라](effective-java/section10/77.Dont_ignore_exceptions.md)
* [1️⃣ 동시성](effective-java/undefined-6/README.md)
  * [78. 공유 중인 가변 데이터는 동기화해 사용하라](effective-java/section11/78.Synchronize_access_to_shared_mutable_data.md)
  * [79. 과도한 동기화는 피하라](effective-java/section11/79.Avoid_excessive_synchronization.md)
  * [80. 스레드보다는 실행자, 태스크, 스트림을 애용하라](effective-java/section11/80.Prefer_executors_tasks_and_streams_to_threads.md)
  * [81. wait와 notify보다는 동시성 유틸리티를 애용하라](effective-java/section11/81.Prefer_concurrency_utilities_to_wait_and_notify.md)
  * [82. 스레드 안전성 수준을 문서화하라](effective-java/section11/82.Document_thread_safety.md)
  * [83. 지연 초기화는 신중히 사용하라](effective-java/section11/83.Use_lazy_initialization_judiciously.md)
  * [84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라](effective-java/section11/84.Dont_depend_on_the_thread_scheduler.md)
* [2️⃣ 직렬화](effective-java/undefined-7/README.md)
  * [85. 자바 직렬화의 대안을 찾으라](effective-java/section12/85.Prefer_alternatives_to_Java_serialization.md)
  * [86. Serializable을 구현할지는 신중히 결정하라](effective-java/section12/86.Implement_Serializable_with_great_caution.md)
  * [87. 커스텀 직렬화 형태를 고려해보라](effective-java/section12/87.Consider_using_a_custom_serialized_form.md)
  * [88. readObject 메서드는 방어적으로 작성하라](effective-java/section12/88.Write_readObject_methods_defensively.md)
  * [89. 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라](effective-java/section12/89.For_instance_control_prefer_enum_types_to_readResolve.md)
  * [90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라](effective-java/section12/90.Consider_serialization_proxies_instead_of_serialized_instances.md)
